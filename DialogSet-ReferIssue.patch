 resip/dum/DialogSet.cxx | 75 +++++++++++++++----------------------------------
 1 file changed, 22 insertions(+), 53 deletions(-)

diff --git a/resip/dum/DialogSet.cxx b/resip/dum/DialogSet.cxx
index 43a25c9e1..2afb71a1f 100644
--- a/resip/dum/DialogSet.cxx
+++ b/resip/dum/DialogSet.cxx
@@ -181,54 +181,6 @@ DialogSet::findDialog(const SipMessage& msg)
       return 0;
    }
    return findDialog(DialogId(msg));
-#if 0   
-   DialogId id(msg);
-   Dialog* dlog = findDialog(id);
-   //vonage/2543 matching here
-   if (dlog)
-   {
-      return dlog;
-   }
-   //match off transaction ID
-   else if (msg.isResponse() && !msg.header(h_To).exists(p_tag))
-   {
-      for(DialogMap::iterator it = mDialogs.begin(); it != mDialogs.end(); it++)
-      {
-         if (it->second->matches(msg))
-         {
-            return it->second;            
-         }
-      }
-   }
-   else if (msg.exists(h_Contacts) && !msg.header(h_Contacts).empty()
-            && msg.isResponse() 
-            && mDum.getProfile()->looseToTagMatching()
-            && msg.header(h_To).exists(p_tag))     
-   {
-      const Uri& contact = msg.header(h_Contacts).front().uri();
-      
-      //match by contact
-      for(DialogMap::iterator it = mDialogs.begin(); it != mDialogs.end(); it++)
-      {
-         if (it->second->mRemoteTarget.uri() == msg.header(h_Contacts).front().uri())
-         {
-            // !dcm! in the vonage case, the to tag should be updated to match the fake
-            //vonage tag introduced in the 200 which is also used for the BYE.
-            //find out how deep this rabbit hole goes, may just have a pugabble
-            //filter api that can be added for dialog matching if things get any
-            //more specific--this is the VonageKludgeFilter
-            Dialog* dialog = it->second;
-            DialogId old = dialog->getId();
-            dialog->mId = DialogId(old.getCallId(), old.getLocalTag(), msg.header(h_To).param(p_tag));
-            dialog->mRemoteNameAddr.param(p_tag) = msg.header(h_To).param(p_tag);
-            mDialogs.erase(it);
-            mDialogs[dialog->getId()] = dialog;
-            return dialog;
-         }
-      }
-   }
-   return 0;
-#endif
 }
 
 bool
@@ -561,17 +513,27 @@ DialogSet::dispatch(const SipMessage& msg)
             break;
             
          case REFER:
-            if (request.header(h_To).exists(p_tag) || findDialog(request))
+            if (dialog)
             {
                DebugLog(<< "in dialog refer request");
                break; // in dialog
             }
+            else if (request.header(h_To).exists(p_tag))
+            {
+                // We have a To tag, but don't have an existing dialog, we shouldn't be creating a new one, reject
+                auto response = std::make_shared<SipMessage>();
+                mDum.makeResponse(*response, msg, 481);
+                mDum.send(std::move(response));
+                return;
+            }
+            // We have an out-of-dialog request, check if it needs an implied subscription dialog
             else if((request.exists(h_ReferSub) && 
                      request.header(h_ReferSub).isWellFormed() &&
                      request.header(h_ReferSub).value()=="false") ||
                      (request.exists(h_Requires) &&
                      request.header(h_Requires).find(Token("norefersub"))))// out of dialog & noReferSub=true
             {
+               // No dialog needed here
                DebugLog(<< "out of dialog refer request with norefersub");
                resip_assert(mServerOutOfDialogRequest == 0);
                mServerOutOfDialogRequest = makeServerOutOfDialog(request);
@@ -583,14 +545,21 @@ DialogSet::dispatch(const SipMessage& msg)
                DebugLog(<< "out of dialog refer request with refer sub");
                break; // dialog creating
             }
-            break;            
-         case NOTIFY:
+            break;
 
-            // !jf! there shouldn't be a dialogset for ServerOutOfDialogReq
-            if (request.header(h_To).exists(p_tag) || findDialog(request))
+         case NOTIFY:
+            if (dialog)
             {
                break; //dialog creating/handled by dialog
             }
+            else if (request.header(h_To).exists(p_tag))
+            {
+                // We have a To tag, but don't have an existing dialog, we shouldn't be creating a new one, reject
+                auto response = std::make_shared<SipMessage>();
+                mDum.makeResponse(*response, msg, 481);
+                mDum.send(std::move(response));
+                return;
+            }
             else // no to tag - unsolicited notify
             {
                // unsolicited - not allowed but commonly implemented
